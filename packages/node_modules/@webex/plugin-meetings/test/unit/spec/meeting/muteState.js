import sinon from 'sinon';
import {assert} from '@webex/test-helper-chai';
import MockWebex from '@webex/test-helper-mock-webex';
import Meetings from '@webex/plugin-meetings';
import MeetingUtil from '@webex/plugin-meetings/src/meeting/util';
import createMuteState from '@webex/plugin-meetings/src/meeting/muteState';
import Media from '@webex/plugin-meetings/src/media/index';
import PermissionError from '@webex/plugin-meetings/src/common/errors/permission';

import testUtils from '../../../utils/testUtils';

const flushPromises = () => new Promise(setImmediate); // todo: use the one from testUtils

describe('plugin-meetings', () => {
  let meeting;
  let audio;
  let video;

  const fakeLocus = {info: 'this is a fake locus'};

  beforeEach(() => {
    // todo not sure if this stuff is needed...
    const webex = new MockWebex({
      children: {
        meetings: Meetings
      }
    });

    webex.meetings.clientRegion = {
      countryCode: 'US',
      regionCode: 'WEST-COAST'
    };
    // ----------------------------------------

    meeting = {
      mediaProperties: {
        audioTrack: 'fake audio track',
        videoTrack: 'fake video track'
      },
      remoteMuted: false,
      unmuteAllowed: true,
      locusInfo: {
        onFullLocus: sinon.stub() // todo: or use sinon.mock()
      },
      members: {
        selfId: 'fake self id',
        muteMember: sinon.stub().resolves()
      }
    };
    audio = createMuteState('audio', meeting, {sendAudio: true});
    video = createMuteState('video', meeting, {sendVideo: true});

    MeetingUtil.remoteUpdateAudioVideo = sinon.stub().resolves(fakeLocus);
    Media.setLocalTrack = sinon.stub();
  });

  describe('mute state library', () => {
    it('does not create an audio instance if we are not sending audio', async () => {
      assert.isNull(createMuteState('audio', meeting, {sendAudio: false}));
      assert.isNull(createMuteState('audio', meeting, {}));
    });

    it('does not create a video instance if we are not sending video', async () => {
      assert.isNull(createMuteState('video', meeting, {sendVideo: false}));
      assert.isNull(createMuteState('video', meeting, {}));
    });

    it('takes into account current remote mute status when instantiated', async () => {
      // simulate being already remote muted
      meeting.remoteMuted = true;

      // create a new MuteState intance
      audio = createMuteState('audio', meeting, {sendAudio: true});

      assert.isTrue(audio.isMuted());
      assert.isFalse(audio.isSelf());

      // now check the opposite case
      meeting.remoteMuted = false;

      // create a new MuteState intance
      audio = createMuteState('audio', meeting, {sendAudio: true});

      assert.isFalse(audio.isMuted());
      assert.isFalse(audio.isSelf());
    });

    it('takes remote mute into account when reporting current state', async () => {
      // simulate remote mute
      audio.handleServerRemoteMuteUpdate(true, true);

      assert.isTrue(audio.isMuted());
      assert.isFalse(audio.isSelf());
    });

    describe('#handleClientRequest', () => {
      it('disables/enables the local audio track when audio is muted/unmuted', async () => {
        // mute
        audio.handleClientRequest(true);
        assert.calledWith(Media.setLocalTrack, false, meeting.mediaProperties.audioTrack);

        // even when calling mute when it's already muted should still call setLocalTrack
        audio.handleClientRequest(true);
        assert.calledWith(Media.setLocalTrack, false, meeting.mediaProperties.audioTrack);

        // unmute
        audio.handleClientRequest(false);
        assert.calledWith(Media.setLocalTrack, true, meeting.mediaProperties.audioTrack);

        // even when calling unmute when it's already unmuted should still call setLocalTrack
        audio.handleClientRequest(false);
        assert.calledWith(Media.setLocalTrack, true, meeting.mediaProperties.audioTrack);
      });

      it('disables/enables the local video track when video is muted/unmuted', async () => {
        // mute
        video.handleClientRequest(true);
        assert.calledWith(Media.setLocalTrack, false, meeting.mediaProperties.videoTrack);

        // even when calling mute when it's already muted should still call setLocalTrack
        video.handleClientRequest(false);
        assert.calledWith(Media.setLocalTrack, false, meeting.mediaProperties.videoTrack);

        // unmute
        video.handleClientRequest(false);
        assert.calledWith(Media.setLocalTrack, true, meeting.mediaProperties.videoTrack);

        // even when calling unmute when it's already unmuted should still call setLocalTrack
        video.handleClientRequest(false);
        assert.calledWith(Media.setLocalTrack, true, meeting.mediaProperties.videoTrack);
      });

      it('returns correct value in isMuted()/isSelf() methods after client mute/unmute requests', async () => {
        // mute
        audio.handleClientRequest(true);

        assert.isTrue(audio.isMuted());
        assert.isTrue(audio.isSelf());

        // unmute
        audio.handleClientRequest(false);

        assert.isFalse(audio.isMuted());
        assert.isFalse(audio.isSelf());
      });

      it('does remote unmute when unmuting and remote mute is on', async () => {
        // simulate remote mute
        audio.handleServerRemoteMuteUpdate(true, true);

        // unmute
        await audio.handleClientRequest(false);

        // check that remote unmute was sent to server
        assert.calledOnce(meeting.members.muteMember);
        assert.calledWith(meeting.members.muteMember, meeting.members.selfId, false);

        assert.isFalse(audio.isMuted());
        assert.isFalse(audio.isSelf());
      });

      it('resolves client request promise once the server is updated', async () => {
        let clientPromiseResolved = false;

        let serverResponseResolve;

        MeetingUtil.remoteUpdateAudioVideo = sinon.stub().returns(new Promise((resolve) => {
          serverResponseResolve = resolve;
        }));

        audio.handleClientRequest(true)
          .then(() => {
            clientPromiseResolved = true;
          });

        // do a small delay to make sure that the client promise doesn't resolve in that time
        await testUtils.waitUntil(200);
        assert.isFalse(clientPromiseResolved);

        // now allow the server response to arrive, this should trigger the client promise to get resolved
        serverResponseResolve();
        await flushPromises();

        assert.isTrue(clientPromiseResolved);
      });

      it('rejects client request promise if server request for local mute fails', async () => {
        MeetingUtil.remoteUpdateAudioVideo = sinon.stub().returns(new Promise((resolve, reject) => {
          reject();
        }));

        assert.isRejected(audio.handleClientRequest(true));
      });

      it('rejects client request promise if server request for remote mute fails', async () => {
        // we only send remote mute requests when we're unmuting, so first we need to do a remote mute
        audio.handleServerRemoteMuteUpdate(true, true);

        // setup the stub to simulate server error response
        meeting.members.muteMember = sinon.stub().rejects();

        // try to unmute - it should fail
        await assert.isRejected(audio.handleClientRequest(false));

        // even though remote mute update in the server failed, isMuted() should still return true,
        // because of local mute
        assert.isTrue(audio.isMuted());
      });

      it('does not send a server request if client state matches the server', async () => {
        let serverResponseResolve;

        MeetingUtil.remoteUpdateAudioVideo = sinon.stub().returns(new Promise((resolve) => {
          serverResponseResolve = resolve;
        }));

        // simulate many client requests, with the last one matching the initial one
        audio.handleClientRequest(true);
        audio.handleClientRequest(false);
        audio.handleClientRequest(true);
        audio.handleClientRequest(false);
        audio.handleClientRequest(true);

        // so far there should have been only 1 request to server (because our stub hasn't resolved yet
        // and MuteState sends only 1 server request at a time)
        assert.calledOnce(MeetingUtil.remoteUpdateAudioVideo);
        MeetingUtil.remoteUpdateAudioVideo.resetHistory();

        // now allow the server response to arrive for that initial request
        serverResponseResolve();
        await flushPromises();

        // there should have not been any more server requests, because client state already matches the server state
        assert.notCalled(MeetingUtil.remoteUpdateAudioVideo);
      });

      it('queues up server requests when multiple client requests are received', async () => {
        let serverResponseResolve;

        MeetingUtil.remoteUpdateAudioVideo = sinon.stub().returns(new Promise((resolve) => {
          serverResponseResolve = resolve;
        }));

        let firstClientPromiseResolved = false;
        let secondClientPromiseResolved = false;

        // 2 client requests, one after another without waiting for first one to resolve
        audio.handleClientRequest(true)
          .then(() => {
            firstClientPromiseResolved = true;
          });
        audio.handleClientRequest(false)
          .then(() => {
            secondClientPromiseResolved = true;
          });

        await flushPromises();

        assert.calledOnce(MeetingUtil.remoteUpdateAudioVideo);
        assert.calledWith(MeetingUtil.remoteUpdateAudioVideo, true, undefined, meeting);

        // now allow the first request to complete
        serverResponseResolve();
        await flushPromises();
        assert.isTrue(firstClientPromiseResolved);

        // that should trigger the second server request to be sent
        assert.calledTwice(MeetingUtil.remoteUpdateAudioVideo);
        assert.strictEqual(false, MeetingUtil.remoteUpdateAudioVideo.getCall(1).args[0]);
        assert.strictEqual(undefined, MeetingUtil.remoteUpdateAudioVideo.getCall(1).args[1]);
        assert.strictEqual(meeting, MeetingUtil.remoteUpdateAudioVideo.getCall(1).args[2]);

        serverResponseResolve();
        await flushPromises();

        assert.isTrue(secondClientPromiseResolved);
      });

      it('rejects client request to unmute if hard mute is used', (done) => {
        audio.handleServerRemoteMuteUpdate(true, false);

        audio.handleClientRequest(false)
          .then(() => {
            done(new Error('expected handleClientRequest to fail, but it did not!'));
          })
          .catch((e) => {
            assert.isTrue(e instanceof PermissionError);
            done();
          });
      });
    });
  });
});
