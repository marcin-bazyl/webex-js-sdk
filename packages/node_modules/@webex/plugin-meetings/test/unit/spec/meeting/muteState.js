import sinon from 'sinon';
import {assert} from '@webex/test-helper-chai';
import MuteState from '@webex/plugin-meetings/src/meeting/muteState';
import PermissionError from '@webex/plugin-meetings/src/common/errors/permission';
import {AUDIO, VIDEO} from '@webex/plugin-meetings/src/constants';

import testUtils from '../../../utils/testUtils';

describe('plugin-meetings', () => {
  let audio;
  let video;
  let callbacks;

  beforeEach(() => {
    const initialState = {remoteMuted: false, unmuteAllowed: true};

    callbacks = {
      enableLocalTrack: sinon.stub(),
      sendLocalMuteToServer: sinon.stub().resolves(),
      sendRemoteMuteToServer: sinon.stub().resolves()
    };
    audio = new MuteState(AUDIO, initialState, callbacks);
    video = new MuteState(VIDEO, initialState, callbacks);
  });

  describe('mute state library', () => {
    it('takes into account initial remote mute status when created', async () => {
      // create a new MuteState intance
      audio = new MuteState(AUDIO, {remoteMuted: true, unmuteAllowed: true}, callbacks);

      assert.isTrue(audio.isMuted());
      assert.isFalse(audio.isSelf());

      // now check the opposite case
      audio = new MuteState(AUDIO, {remoteMuted: false, unmuteAllowed: true}, callbacks);

      assert.isFalse(audio.isMuted());
      assert.isFalse(audio.isSelf());
    });

    it('takes remote mute into account when reporting current state', async () => {
      assert.isFalse(audio.isMuted());

      // simulate remote mute
      audio.handleServerRemoteMuteUpdate(true, true);

      assert.isTrue(audio.isMuted());
      assert.isFalse(audio.isSelf());
    });

    it('does local unmute if localAudioUnmuteRequired is received', async () => {
      // first we need to mute
      await audio.handleClientRequest(true);

      assert.isTrue(audio.isMuted());
      assert.isTrue(audio.isSelf());

      callbacks.sendLocalMuteToServer.resetHistory();

      // now simulate server requiring us to locally unmute
      audio.handleServerLocalUnmuteRequired();
      await testUtils.flushPromises();

      // check that local track was enabled
      assert.calledWith(callbacks.enableLocalTrack, true);

      // and local unmute was sent to server
      assert.calledOnce(callbacks.sendLocalMuteToServer);
      assert.calledWith(callbacks.sendLocalMuteToServer, false, undefined);

      assert.isFalse(audio.isMuted());
      assert.isFalse(audio.isSelf());
    });

    it('rejects client request in progress if localAudioUnmuteRequired is received', async () => {
      let clientPromiseResolved = false;
      let clientPromiseRejected = false;

      // first we need to mute and make that request last forever
      let serverResponseResolve;

      callbacks.sendLocalMuteToServer = sinon.stub().returns(new Promise((resolve) => {
        serverResponseResolve = resolve;
      }));

      audio.handleClientRequest(true)
        .then(() => {
          clientPromiseResolved = true;
        })
        .catch(() => {
          clientPromiseRejected = true;
        });

      callbacks.sendLocalMuteToServer.resetHistory();

      // now simulate server requiring us to locally unmute
      audio.handleServerLocalUnmuteRequired();
      await testUtils.flushPromises();

      // the original client request should have been rejected by now
      assert.isTrue(clientPromiseRejected);
      assert.isFalse(clientPromiseResolved);

      // now make the server respond to the original mute request
      serverResponseResolve();
      await testUtils.flushPromises();

      // local unmute should be sent to server
      assert.calledOnce(callbacks.sendLocalMuteToServer);
      assert.calledWith(callbacks.sendLocalMuteToServer, false, undefined);

      // and local track should be enabled
      assert.calledWith(callbacks.enableLocalTrack, true);

      assert.isFalse(audio.isMuted());
      assert.isFalse(audio.isSelf());
    });

    describe('#handleClientRequest', () => {
      it('disables/enables the local track when muted/unmuted by client', async () => {
        // mute
        audio.handleClientRequest(true);
        assert.calledWith(callbacks.enableLocalTrack, false);

        // even when calling mute when it's already muted should still call setLocalTrack
        audio.handleClientRequest(true);
        assert.calledWith(callbacks.enableLocalTrack, false);

        // unmute
        audio.handleClientRequest(false);
        assert.calledWith(callbacks.enableLocalTrack, true);

        // even when calling unmute when it's already unmuted should still call setLocalTrack
        audio.handleClientRequest(false);
        assert.calledWith(callbacks.enableLocalTrack, true);
      });

      it('returns correct value in isMuted()/isSelf() methods after client mute/unmute requests', async () => {
        // mute
        audio.handleClientRequest(true);

        assert.isTrue(audio.isMuted());
        assert.isTrue(audio.isSelf());

        // unmute
        audio.handleClientRequest(false);

        assert.isFalse(audio.isMuted());
        assert.isFalse(audio.isSelf());
      });

      it('does remote unmute when unmuting and remote mute is on', async () => {
        // simulate remote mute
        audio.handleServerRemoteMuteUpdate(true, true);

        // unmute
        await audio.handleClientRequest(false);

        // check that remote unmute was sent to server
        assert.calledOnce(callbacks.sendRemoteMuteToServer);
        assert.calledWith(callbacks.sendRemoteMuteToServer, false);

        assert.isFalse(audio.isMuted());
        assert.isFalse(audio.isSelf());
      });

      it('resolves client request promise once the server is updated', async () => {
        let clientPromiseResolved = false;

        let serverResponseResolve;

        callbacks.sendLocalMuteToServer = sinon.stub().returns(new Promise((resolve) => {
          serverResponseResolve = resolve;
        }));

        audio.handleClientRequest(true)
          .then(() => {
            clientPromiseResolved = true;
          });

        // do a small delay to make sure that the client promise doesn't resolve in that time
        await testUtils.waitUntil(200);
        assert.isFalse(clientPromiseResolved);

        // now allow the server response to arrive, this should trigger the client promise to get resolved
        serverResponseResolve();
        await testUtils.flushPromises();

        assert.isTrue(clientPromiseResolved);
      });

      it('rejects client request promise if server request for local mute fails', async () => {
        callbacks.sendLocalMuteToServer = sinon.stub().returns(new Promise((resolve, reject) => {
          reject();
        }));

        assert.isRejected(audio.handleClientRequest(true));
      });

      it('rejects client request promise if server request for remote mute fails', async () => {
        // we only send remote mute requests when we're unmuting, so first we need to do a remote mute
        audio.handleServerRemoteMuteUpdate(true, true);

        // setup the stub to simulate server error response
        callbacks.sendRemoteMuteToServer = sinon.stub().rejects();

        // try to unmute - it should fail
        await assert.isRejected(audio.handleClientRequest(false));

        // even though remote mute update in the server failed, isMuted() should still return true,
        // because of local mute
        assert.isTrue(audio.isMuted());
      });

      it('does not send a server request if client state matches the server', async () => {
        let serverResponseResolve;

        callbacks.sendLocalMuteToServer = sinon.stub().returns(new Promise((resolve) => {
          serverResponseResolve = resolve;
        }));

        // simulate many client requests, with the last one matching the initial one
        audio.handleClientRequest(true);
        audio.handleClientRequest(false);
        audio.handleClientRequest(true);
        audio.handleClientRequest(false);
        audio.handleClientRequest(true);

        // so far there should have been only 1 request to server (because our stub hasn't resolved yet
        // and MuteState sends only 1 server request at a time)
        assert.calledOnce(callbacks.sendLocalMuteToServer);
        callbacks.sendLocalMuteToServer.resetHistory();

        // now allow the server response to arrive for that initial request
        serverResponseResolve();
        await testUtils.flushPromises();

        // there should have not been any more server requests, because client state already matches the server state
        assert.notCalled(callbacks.sendLocalMuteToServer);
      });

      it('queues up server requests when multiple client requests are received', async () => {
        let serverResponseResolve;

        callbacks.sendLocalMuteToServer = sinon.stub().returns(new Promise((resolve) => {
          serverResponseResolve = resolve;
        }));

        let firstClientPromiseResolved = false;
        let secondClientPromiseResolved = false;

        // 2 client requests, one after another without waiting for first one to resolve
        audio.handleClientRequest(true)
          .then(() => {
            firstClientPromiseResolved = true;
          });
        audio.handleClientRequest(false)
          .then(() => {
            secondClientPromiseResolved = true;
          });

        await testUtils.flushPromises();

        assert.calledOnce(callbacks.sendLocalMuteToServer);
        assert.calledWith(callbacks.sendLocalMuteToServer, true, undefined);

        // now allow the first request to complete
        serverResponseResolve();
        await testUtils.flushPromises();
        assert.isTrue(firstClientPromiseResolved);

        // that should trigger the second server request to be sent
        assert.calledTwice(callbacks.sendLocalMuteToServer);
        assert.strictEqual(false, callbacks.sendLocalMuteToServer.getCall(1).args[0]);
        assert.strictEqual(undefined, callbacks.sendLocalMuteToServer.getCall(1).args[1]);

        serverResponseResolve();
        await testUtils.flushPromises();

        assert.isTrue(secondClientPromiseResolved);
      });

      it('rejects client request to unmute if hard mute is used', (done) => {
        audio.handleServerRemoteMuteUpdate(true, false);

        audio.handleClientRequest(false)
          .then(() => {
            done(new Error('expected handleClientRequest to fail, but it did not!'));
          })
          .catch((e) => {
            assert.isTrue(e instanceof PermissionError);
            done();
          });
      });

      it('does not send remote mute for video', async () => {
        // mute
        await video.handleClientRequest(true);

        assert.isTrue(video.isMuted());
        assert.isTrue(video.isSelf());

        // check local mute is done, but not remote one
        assert.calledWith(callbacks.enableLocalTrack, false);
        assert.calledWith(callbacks.sendLocalMuteToServer, undefined, true);
        assert.notCalled(callbacks.sendRemoteMuteToServer);

        callbacks.enableLocalTrack.resetHistory();
        callbacks.sendLocalMuteToServer.resetHistory();
        callbacks.sendRemoteMuteToServer.resetHistory();

        // unmute
        await video.handleClientRequest(false);

        assert.isFalse(video.isMuted());
        assert.isFalse(video.isSelf());

        assert.calledWith(callbacks.enableLocalTrack, true);
        assert.calledWith(callbacks.sendLocalMuteToServer, undefined, false);
        assert.notCalled(callbacks.sendRemoteMuteToServer);
      });
    });
  });
});
