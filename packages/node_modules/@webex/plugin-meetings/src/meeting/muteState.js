
import LoggerProxy from '../common/logs/logger-proxy';
import ParameterError from '../common/errors/parameter';
import Media from '../media';
import MeetingUtil from '../meeting/util';

const TYPE_AUDIO = 'audio';
const TYPE_VIDEO = 'video';

// todo consider doing remote mute every time with local mute

/* todo:
  Certain aspects of server interaction for video muting are not implemented as we currently don't support remote muting of video.
  If we ever need to support it, search for REMOTE_MUTE_VIDEO_MISSING_IMPLEMENTATION string to find the places that need updating
*/

const createMuteState = (type, meeting, mediaDirection) => {
  if (!mediaDirection.sendAudio) {
    return null;
  }
  console.log('marcin: creating MuteState(', type, ')');

  return new MuteState(type, meeting);
};

/* eslint class-methods-use-this: ["error", { "exceptMethods": ["isSelf"] }] */

class MuteState {
  constructor(type, meeting) {
    // todo: initial values?
    // todo: current code doesn't create the state machine when we're not sending audio at all, I think we need to change this because the new SM handles also remote mute
    if ((type !== TYPE_AUDIO) && (type !== TYPE_VIDEO)) {
      throw new ParameterError('Mute state is designed for handling audio or video only');
    }
    if (!meeting) {
      throw new ParameterError('Mute state requires a meeting instance');
    }
    this.type = type;
    this.meeting = meeting;
    this.state = {
      client: {
        localMute: false,
      },
      server: {
        localMute: false,
        remoteMute: false
      },
      syncToServerInProgress: false
    };
    // these 2 hold the resolve, reject methods for the promise we returned to the client in last handleClientRequest() call
    this.pendingPromiseResolve = null;
    this.pendingPromiseReject = null;
  }

  handleClientRequest(mute) {
    LoggerProxy.logger.info(`Meeting:muteState#handleClientRequest --> ${this.type}: user requesting new mute state: ${mute}`);

    // we don't check if we're already in the same state, because even if we were, we would still have to apply the mute state locally,
    // because the client may have changed the audio/vidoe tracks
    this.state.client.localMute = mute;
    this.applyClientStateLocally();

    return new Promise((resolve, reject) => {
      if (this.pendingPromiseResolve) {
        // resolve the last promise we returned to the client as the client has issued a new request that has superseded the previous one
        this.pendingPromiseResolve();
      }
      this.pendingPromiseResolve = resolve;
      this.pendingPromiseReject = reject;
      this.applyClientStateToServer();
    });
  }

  /**
   * Applies the current mute state to the local track (by enabling or disabling it accordingly)
   *
   * @public
   * @memberof MuteState
   * @returns {void}
   */
  applyClientStateLocally() {
    Media.setLocalTrack(
      !this.state.client.localMute,
      (this.type === TYPE_AUDIO) ? this.meeting.mediaProperties.audioTrack : this.meeting.mediaProperties.videoTrack
    );
  }

  applyClientStateToServer() {

    if (this.state.syncToServerInProgress) {
      LoggerProxy.logger.info(`Meeting:muteState#applyClientStateToServer --> ${this.type}: request to server in progress, we need to wait for it to complete`);
      return;
    }

    const localMuteRequiresSync = (this.state.client.localMute !== this.state.server.localMute);
    const remoteMuteRequiresSync = (!this.state.client.localMute && this.state.server.remoteMute);

    LoggerProxy.logger.info(`Meeting:muteState#applyClientStateToServer --> ${this.type}: localMuteRequiresSync: ${localMuteRequiresSync} (${this.state.client.localMute} ?= ${this.state.server.localMute})`);
    LoggerProxy.logger.info(`Meeting:muteState#applyClientStateToServer --> ${this.type}: remoteMuteRequiresSync: ${remoteMuteRequiresSync}`);

    if (!localMuteRequiresSync && !remoteMuteRequiresSync) {
      LoggerProxy.logger.info(`Meeting:muteState#applyClientStateToServer --> ${this.type}: client state already matching server state, nothing to do`);

      this.pendingPromiseResolve();
      this.pendingPromiseResolve = null;
      this.pendingPromiseReject = null;
      return;
    }

    this.state.syncToServerInProgress = true;

    // first sync local mute with server
    const localMuteSyncPromise = (localMuteRequiresSync) ? this.sendLocalMuteRequestToServer() : Promise.resolve();

    localMuteSyncPromise
      .then(() =>
        // then follow it up with remote mute sync
        ((remoteMuteRequiresSync) ? this.sendRemoteMuteRequestToServer() : Promise.resolve()))
      .then(() => {
        this.state.syncToServerInProgress = false;
        LoggerProxy.logger.info(`Meeting:muteState#applyClientStateToServer --> ${this.type}: sync with server completed`);

        // need to check if a new sync is required, because this.state.client may have changed while we were doing the current sync
        this.applyClientStateToServer();
      })
      .catch((e) => {
        this.state.syncToServerInProgress = false;

        this.pendingPromiseReject(e);
        this.pendingPromiseResolve = null;
        this.pendingPromiseReject = null;
      });
  }

  sendLocalMuteRequestToServer() {
    const meetingAudio = this.meeting.audio;
    const meetingVideo = this.meeting.video;

    let audioMuted = (meetingAudio ? meetingAudio.muted : true);
    let videoMuted = (meetingVideo ? meetingVideo.muted : true);

    if (this.type === TYPE_AUDIO) {
      audioMuted = this.state.client.localMute;
    }
    else {
      videoMuted = this.state.client.localMute;
    }

    LoggerProxy.logger.info(`Meeting:muteState#sendLocalMuteRequestToServer --> ${this.type}: sending local mute (audio=${audioMuted}, video=${videoMuted}) to server`);

    return MeetingUtil.remoteUpdateAudioVideo(audioMuted, videoMuted, this.meeting)
      .then((locus) => {
        LoggerProxy.logger.info(
          `Meeting:muteState#sendLocalMuteRequestToServer --> ${this.type}: local mute (audio=${audioMuted}, video=${videoMuted}) applied to server`
        );

        // todo: temp hack, really I think we should parse the locus reply and make sure that onFullLocus ends up calling handleServerLocalMuteUpdate - although not sure about 429 case
        this.state.server.localMute = (this.type === TYPE_AUDIO) ? audioMuted : videoMuted;

        this.meeting.locusInfo.onFullLocus(locus); // this will also end up calling handleServerLocalMuteUpdate() ( todo )

        return locus;
      })
      .catch((remoteUpdateError) => {
        LoggerProxy.logger.info(
          `Meeting:muteState#sendLocalMuteRequestToServer --> ${this.type}: failed to apply local mute (audio=${audioMuted}, video=${videoMuted}) to server: ${remoteUpdateError}`
        );

        return Promise.reject(remoteUpdateError);
      });
  }

  sendRemoteMuteRequestToServer() {
    if (this.type === TYPE_AUDIO) {
      const remoteMute = this.state.client.localMute;

      LoggerProxy.logger.info(`Meeting:muteState#sendRemoteMuteRequestToServer --> ${this.type}: sending remote mute:${remoteMute} to server`);

      return this.meeting.members.muteMember(this.meeting.members.selfId, remoteMute)
        .then(() => {
          LoggerProxy.logger.info(
            `Meeting:muteState#sendRemoteMuteRequestToServer --> ${this.type}: remote mute:${remoteMute} applied to server`
          );

          // todo: decide if we want to keep this (probably not?)
          this.state.server.remoteMute = remoteMute;
        })
        .catch((remoteUpdateError) => {
          LoggerProxy.logger.info(
            `Meeting:muteState#sendRemoteMuteRequestToServer --> ${this.type}: failed to apply remote mute ${remoteMute} to server: ${remoteUpdateError}`
          );

          return Promise.reject(remoteUpdateError);
        });
    }

    // for now we don't need to support remote muting of video (REMOTE_MUTE_VIDEO_MISSING_IMPLEMENTATION)
    return Promise.resolve();
  }

  // handleServerLocalMuteUpdate() {
  //   // todo
  // }

  handleServerRemoteMuteUpdate(muted) {
    if (muted === this.state.server.remoteMute) {
      LoggerProxy.logger.info(`Meeting:muteState#handleServerRemoteMuteUpdate --> ${this.type}: server.remoteMute already matching server state (${muted})`);
    }

    LoggerProxy.logger.info(`Meeting:muteState#handleServerRemoteMuteUpdate --> ${this.type}: updating server remoteMute to (${muted})`);
    this.state.server.remoteMute = muted;
    // todo: notification to the user - should it be from here or the layer that calls handleServerRemoteMuteUpdate() ?
  }

  // these 2 methods are here just for backward compatibility
  isMuted() {
    return this.state.client.localMute || this.state.server.localMute || this.state.server.remoteMute;
  }

  isSelf() {
    return true; // yes, this is silly, but that's what we've been always returning // todo (remove eslint directive if we fix this)
  }
}
// todo: handle 429


// todo
// webex-web-client Module:MeetingsComponent Method:joinMeetingAction Error:Cannot read property 'then' of undefined status code: 0, error code: 0, tracking id: none  Log:error joining meeting with destination

export default createMuteState;
