/* eslint-disable require-jsdoc */
/* eslint-disable import/prefer-default-export */

import {getMaxFs, RemoteMedia, RemoteVideoResolution} from './remoteMedia';
import {MediaRequestId, MediaRequestManager} from './mediaRequestManager';
import {CSI, ReceiveSlot} from './receiveSlot';

type Options = {
  resolution? : RemoteVideoResolution, // applies only to groups of type MC.MediaType.VideoMain and MC.MediaType.VideoSlides
  preferLiveVideo? : boolean, // applies only to groups of type MC.MediaType.VideoMain and MC.MediaType.VideoSlides
};

export class RemoteMediaGroup {
  private mediaRequestManager: MediaRequestManager;

  private priority : number;

  private options : Options;

  public readonly remoteMedia : RemoteMedia[]; // todo: check if clients can append/splice it etc

  private mediaRequestId?: MediaRequestId; // id of the "active-speaker" media request id

  public readonly pinnedRemoteMedia : RemoteMedia[];

  constructor(
    mediaRequestManager: MediaRequestManager,
    receiveSlots: ReceiveSlot[],
    priority: number,
    options: Options = {}
  ) {
    this.mediaRequestManager = mediaRequestManager;
    this.priority = priority;
    this.options = options;

    this.remoteMedia = receiveSlots.map((slot) => new RemoteMedia(slot, this.mediaRequestManager, {
      resolution: this.options.resolution
    }));
    this.pinnedRemoteMedia = [];
  }

  public pin(remoteMedia: RemoteMedia, csi?: CSI) : void {
    if (this.pinnedRemoteMedia.indexOf(remoteMedia) >= 0) {
      console.log(`remote media object ${remoteMedia.id} already pinned`);

      return;
    }
    const idx = this.remoteMedia.indexOf(remoteMedia);

    if (idx < 0) {
      throw new Error(`failed to pin a remote media object ${remoteMedia.id}, because it is not found in this remote media group`);
    }

    // if csi is not specified, use the current one
    const targetCsi = csi || remoteMedia.csi;

    if (targetCsi) {
      this.remoteMedia.splice(idx, 1);
      this.pinnedRemoteMedia.push(remoteMedia);

      this.cancelMediaRequest(false);
      this.sendMediaRequest(false);
      remoteMedia.sendMediaRequest(targetCsi, true);
    }
  }

  public unpin(remoteMedia : RemoteMedia) {
    if (this.remoteMedia.indexOf(remoteMedia) >= 0) {
      console.log(`remote media object ${remoteMedia.id} already unpinned`);

      return;
    }
    const idx = this.pinnedRemoteMedia.indexOf(remoteMedia);

    if (idx < 0) {
      throw new Error(`failed to unpin a remote media object ${remoteMedia.id}, because it is not found in this remote media group's pinned list`);
    }

    this.pinnedRemoteMedia.splice(idx, 1);
    this.remoteMedia.push(remoteMedia);

    remoteMedia.cancelMediaRequest(false);
    this.cancelMediaRequest(false);
    this.sendMediaRequest(true);
  }

  /**
   * @internal
   */
  public sendMediaRequest(commit: boolean) {
    if (this.mediaRequestId) {
      this.cancelMediaRequest(false);
    }
    this.mediaRequestId = this.mediaRequestManager.addRequests([{
      policyInfo: {
        policy: 'active-speaker',
        priority: this.priority,
        crossPriorityDuplication: false,
        crossPolicyDuplication: false,
        preferLiveVideo: !!this.options?.preferLiveVideo
      },
      receiveSlots: this.remoteMedia.map((remoteMedia) => remoteMedia.getUnderlyingReceiveSlot()) as ReceiveSlot[],
      codecInfo: this.options.resolution && {
        codec: 'h264',
        maxFs: getMaxFs(this.options.resolution),
      }
    }], commit)[0];
  }

  /**
   *
   * @internal
   */
  public cancelMediaRequest(commit: boolean) {
    if (this.mediaRequestId) {
      this.mediaRequestManager.cancelRequests([this.mediaRequestId], commit);
      this.mediaRequestId = undefined;
    }
  }

  /**
   * Invalidates the remote media group by clearing the reference to the receive slots.
   * After this call the remote media group is unusable.
   *
   * @internal
   */
  public invalidate() {
    this.remoteMedia.forEach((remoteMedia) => remoteMedia.invalidate());
    this.pinnedRemoteMedia.forEach((remoteMedia) => remoteMedia.invalidate());
  }

  public includes(remoteMedia: RemoteMedia): boolean {
    return this.remoteMedia.includes(remoteMedia);
  }

  /**
   * Calls checkMediaAlreadyStarted() on all remoteMedia and pinnedRemoteMedia
   *
   * @internal
   */
  public checkMediaAlreadyStarted() {
    this.remoteMedia.forEach((remoteMedia) => remoteMedia.checkMediaAlreadyStarted());
    this.pinnedRemoteMedia.forEach((remoteMedia) => remoteMedia.checkMediaAlreadyStarted());
  }
}
