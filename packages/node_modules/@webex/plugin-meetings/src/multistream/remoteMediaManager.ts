import {EventEmitter} from 'events';

import {cloneDeep, remove} from 'lodash';
import {EventMap} from 'typed-emitter';
import {MediaConnection as MC} from '@webex/internal-media-core';

import {RemoteMedia, RemoteVideoResolution} from './remoteMedia';
import {ReceiveSlot, CSI} from './receiveSlot';
import {ReceiveSlotManager} from './receiveSlotManager';
import {RemoteMediaGroup} from './remoteMediaGroup';
import {MediaRequestManager} from './mediaRequestManager';

export type PaneSize = RemoteVideoResolution;
export type LayoutId = string;
export type PaneId = string;
export type PaneGroupId = string;

export interface ActiveSpeakerVideoPaneGroup {
  id: PaneGroupId;
  numPanes: number; // maximum number of panes in the group (actual number may be lower, if there are not enough participants in the meeting)
  size: PaneSize; // preferred size for all panes in the group
  priority: number; // 0-255 (255 = highest priority), each group must have a different priority from all other groups
}

export interface MemberVideoPane {
  id: PaneId;
  size: PaneSize;
  csi?: CSI
}

export interface VideoLayout {
  screenShareVideo: {
    size: PaneSize | null; // null if you don't want to receive any screen share video
  }
  activeSpeakerVideoPaneGroups?: ActiveSpeakerVideoPaneGroup[]; // list of active speaker video pane groups
  memberVideoPanes?: MemberVideoPane[]; // list of video panes for specific members, CSI values can be changed later via setVideoPaneCsi()
}

export interface Configuration {
    audio: {
      numOfActiveSpeakerStreams: number; // number of audio streams we want to receive
    },
    video: {
      preferLiveVideo: boolean; // applies to all pane groups with active speaker policy
      initialLayoutId: LayoutId;

      layouts: { [key: LayoutId]: VideoLayout}; // a map of all available layouts, a layout can be set via setLayout() method
    },
    screenShare: {
      audio: boolean; // whether we ever want to receive screen share audio at all
      video: boolean; // whether we ever want to receive screen share video at all
    },
}

/* Predefined layouts: */

// An "all equal" grid, with size up to 3 x 3 = 9:
const AllEqualLayout: VideoLayout = {
  screenShareVideo: {size: null},
  activeSpeakerVideoPaneGroups: [{
    id: 'main',
    numPanes: 9,
    size: 'best',
    priority: 255
  }]
};

// A layout with just a single remote active speaker video pane:
const SingleLayout: VideoLayout = {
  screenShareVideo: {size: null},
  activeSpeakerVideoPaneGroups: [{
    id: 'main',
    numPanes: 1,
    size: 'best',
    priority: 255
  }]
};

// A layout with 1 big pane for the highest priority active speaker and 5 small panes for other active speakers:
const OnePlusFiveLayout: VideoLayout = {
  screenShareVideo: {size: null},
  activeSpeakerVideoPaneGroups: [{
    id: 'mainBigOne',
    numPanes: 1,
    size: 'large',
    priority: 255
  }, {
    id: 'secondarySetOfSmallPanes',
    numPanes: 5,
    size: 'very small',
    priority: 254
  }]
};

// A layout with 2 big panes for 2 main active speakers and a strip of 6 small panes for other active speakers:
const TwoMainPlusSixSmallLayout: VideoLayout = {
  screenShareVideo: {size: null},
  activeSpeakerVideoPaneGroups: [{
    id: 'mainGroupWith2BigPanes',
    numPanes: 2,
    size: 'large',
    priority: 255
  }, {
    id: 'secondaryGroupOfSmallPanes',
    numPanes: 6,
    size: 'small',
    priority: 254
  }]
};

// A strip of 8 small video panes (thumbnails) displayed at the top of a remote screenshare:
const RemoteScreenShareWithSmallThumbnailsLayout: VideoLayout = {
  screenShareVideo: {size: 'best'},
  activeSpeakerVideoPaneGroups: [{
    id: 'thumbnails',
    numPanes: 8,
    size: 'thumbnail',
    priority: 255
  }]
};

// A staged layout with 4 pre-selected meeting participants in the main 2x2 grid and 6 small panes for other active speakers at the top:
const Stage2x2With6ThumbnailsLayout: VideoLayout = {
  screenShareVideo: {size: null},
  activeSpeakerVideoPaneGroups: [{
    id: 'thumbnails',
    numPanes: 6,
    size: 'thumbnail',
    priority: 255
  }],
  memberVideoPanes: [
    {id: 'stage-1', size: 'medium', csi: undefined},
    {id: 'stage-2', size: 'medium', csi: undefined},
    {id: 'stage-3', size: 'medium', csi: undefined},
    {id: 'stage-4', size: 'medium', csi: undefined},
  ]
};

/**
 * Default configuration:
 * - uses 3 audio streams
 * - prefers active speakers with live video (e.g. are not audio only or video muted) over active speakers without live video
 * - has a few layouts defined, including 1 that contains remote screen share (ScreenShareView)
 */
export const DefaultConfiguration: Configuration = {
  audio: {
    numOfActiveSpeakerStreams: 3,
  },
  video: {
    preferLiveVideo: true,
    initialLayoutId: 'AllEqual',

    layouts: {
      AllEqual: AllEqualLayout,
      OnePlusFive: OnePlusFiveLayout,
      Single: SingleLayout,
      Stage: Stage2x2With6ThumbnailsLayout,
      ScreenShareView: RemoteScreenShareWithSmallThumbnailsLayout,
    }
  },
  screenShare: {
    audio: true,
    video: true,
  },
};

export enum Event {
  // events for audio streams
  AudioCreated = 'AudioCreated',
  ScreenShareAudioCreated = 'ScreenShareCreated',

  // events for video streams
  VideoLayoutChanged = 'VideoLayoutChanged',
}

export interface VideoLayoutChangedEventData {
  layoutId: LayoutId,
  activeSpeakerVideoPanes: {
    [key: PaneGroupId]: RemoteMediaGroup,
  },
  memberVideoPanes: {[key: PaneId]: RemoteMedia},
  screenShareVideo?: RemoteMedia
}
export interface Events extends EventMap {
  // audio
  [Event.AudioCreated]: (audio: RemoteMediaGroup) => void;
  [Event.ScreenShareAudioCreated]: (screenShareAudio: RemoteMedia) => void;

  // video
  [Event.VideoLayoutChanged]: (data: VideoLayoutChangedEventData) => void;
}

/**
 * A helper class that manages all remote audio/video streams in order to achieve a predefined set of layouts.
 * It also creates a fixed number of audio streams and these don't change during the meeting.
 *
 * Things that RemoteMediaManager does:
 * - owns the receive slots (creates them when needed, and re-uses them when switching layouts)
 * - constructs appropriate RemoteMedia and RemoteMediaGroup objects and sends appropriate mediaRequests
 */
export class RemoteMediaManager extends EventEmitter {
  private config: Configuration;

  private receiveSlotManager: ReceiveSlotManager;

  private mediaRequestManagers: {
    audio: MediaRequestManager,
    video: MediaRequestManager,
  };

  private currentLayout?: VideoLayout;

  private slots: {
    audio: ReceiveSlot[],
    screenShareAudio?: ReceiveSlot,
    screenShareVideo?: ReceiveSlot,
    video: {
      unused: ReceiveSlot[],
      activeSpeaker: ReceiveSlot[],
      receiverSelected: ReceiveSlot[],
    }
  };

  private media: {
    audio?: RemoteMediaGroup;
    video: {
      activeSpeakerVideoPanes: { // todo: rename to activeSpeakerGroups and memberPanes ?
        [key: PaneGroupId]: RemoteMediaGroup,
      },
      memberVideoPanes: {[key: PaneId]: RemoteMedia},
    }
  };

  private receiveSlotAllocations: {
    activeSpeaker: {[key: PaneGroupId]: {slots: ReceiveSlot[]}},
    receiverSelected: {[key: PaneId]: ReceiveSlot}
  };

  public currentLayoutId: LayoutId;

  /**
   * Constructor
   *
   * @param {ReceiveSlotManager} receiveSlotManager
   * @param {{audio: MediaRequestManager, video: mediaRequestManagers}} mediaRequestManagers
   * @param {Configuration} config Configuration describing what video layouts to use during the meeting
   */
  constructor(
    receiveSlotManager: ReceiveSlotManager,
    mediaRequestManagers: {
      audio: MediaRequestManager,
      video: MediaRequestManager,
    },
    config: Configuration = DefaultConfiguration
  ) {
    super();
    this.config = config;
    this.receiveSlotManager = receiveSlotManager;
    this.mediaRequestManagers = mediaRequestManagers;
    this.media = {
      audio: undefined,
      video: {
        activeSpeakerVideoPanes: {},
        memberVideoPanes: {},
      }
    };

    // todo: check if config is valid (if initialLayoutId matches some layout, etc)

    this.slots = {
      audio: [],
      screenShareAudio: undefined,
      screenShareVideo: undefined,
      video: {
        unused: [],
        activeSpeaker: [],
        receiverSelected: [],
      }
    };

    this.receiveSlotAllocations = {activeSpeaker: {}, receiverSelected: {}};

    console.log(`marcin: RemoteMediaManager created with config: ${JSON.stringify(this.config)}`);
  }

  /**
   * Starts the RemoteMediaManager.
   *
   * @returns {Promise}
   */
  public async start() {
    // todo: check that we have a media connection and that it's a multistream one
    await this.createAudioMedia();

    // todo: create screen share audio remote media
    // todo: create screen share video receive slot

    await this.preallocateVideoReceiveSlots();

    await this.setLayout(this.config.video.initialLayoutId);
  }

  /**
   * Releases all the used resources (like allocated receive slots). This function needs
   * to be called when we leave the meeting, etc.
   */
  public stop() {
    // invalidate all remoteMedia objects
    this.invalidateCurrentRemoteMedia({audio: true, video: true, commit: false});

    this.mediaRequestManagers.audio.commit();
    this.mediaRequestManagers.video.commit();

    // release all receive slots
    this.slots.audio.forEach((slot) => this.receiveSlotManager.releaseSlot(slot));

    // todo: screenshare slots...

    this.receiveSlotAllocations = {activeSpeaker: {}, receiverSelected: {}};

    this.slots.video.unused.push(...this.slots.video.activeSpeaker);
    this.slots.video.activeSpeaker.length = 0;

    this.slots.video.unused.push(...this.slots.video.receiverSelected);
    this.slots.video.receiverSelected.length = 0;

    this.releaseUnusedSlots();

    this.currentLayout = undefined;
    this.currentLayoutId;
  }

  /**
   * Returns the total number of main video panes required for a given layout
   *
   * @param {VideoLayout} layout
   * @returns {number}
   */
  private getRequiredNumVideoSlotsForLayout(layout?: VideoLayout) {
    if (!layout) {
      return 0;
    }

    const activeSpeakerCount = layout.activeSpeakerVideoPaneGroups?.reduce((sum, paneGroup) => sum + paneGroup.numPanes, 0) || 0;

    const receiverSelectedCount = layout.memberVideoPanes?.length || 0;

    return activeSpeakerCount + receiverSelectedCount;
  }

  /**
   * Allocates the maximum number of panes that any of the configured layouts will require.
   * We do this at the beginning, because it's more efficient (much faster) then allocating receive slots
   * later, after the SDP exchange was done.
   */
  private async preallocateVideoReceiveSlots() {
    const maxNumVideoPanesRequired = Object.values(this.config.video.layouts)
      .reduce((maxValue, layout) => Math.max(
        maxValue,
        this.getRequiredNumVideoSlotsForLayout(layout)
      ), 0);

    while (this.slots.video.unused.length < maxNumVideoPanesRequired) {
      // eslint-disable-next-line no-await-in-loop
      this.slots.video.unused.push(await this.receiveSlotManager.allocateSlot(MC.MediaType.VideoMain));
    }
  }

  /**
   * Changes the layout (triggers Event.VideoLayoutChanged)
   *
   * @param {LayoutId} layoutId new layout id
   * @returns {Promise}
   */
  public async setLayout(layoutId: LayoutId) {
    this.currentLayoutId = layoutId;
    this.currentLayout = cloneDeep(this.config.video.layouts[this.currentLayoutId]);

    await this.updateReceiveSlots();
    this.updateRemoteMediaObjects();
    this.emitVideoLayoutChangedEvent();
  }

  /**
   * Returns the currently selected layout id
   *
   * @returns {LayoutId}
   */
  public getLayoutId(): LayoutId {
    return this.currentLayoutId;
  }

  /**
   * Creates the audio slots
   */
  private async createAudioMedia() {
    // create the audio receive slots
    for (let i = 0; i < this.config.audio.numOfActiveSpeakerStreams; i += 1) {
      // eslint-disable-next-line no-await-in-loop
      const slot = await this.receiveSlotManager.allocateSlot(MC.MediaType.AudioMain);

      this.slots.audio.push(slot);
    }

    // create a remote media group
    this.media.audio = new RemoteMediaGroup(this.mediaRequestManagers.audio, this.slots.audio, 255);
    this.media.audio.sendMediaRequest(true);

    this.emit(Event.AudioCreated, this.media.audio);
  }

  /**
   * Goes over all receiver-selected slots and keeps only the ones that are required by a given layout,
   * the rest are all moved to the "unused" list
   */
  private trimReceiverSelectedSlots() {
    const requiredCsis = {};

    // fill requiredCsis with all the CSIs that the given layout requires
    this.currentLayout?.memberVideoPanes?.forEach((memberVideoPane) => {
      if (memberVideoPane.csi !== undefined) {
        requiredCsis[memberVideoPane.csi] = true;
      }
    });

    const isCsiNeededByCurrentLayout = (csi?: CSI) => {
      if (csi === undefined) {
        return false;
      }

      return requiredCsis[csi];
    };

    // keep receiverSelected slots that match our new requiredCsis, move the rest of receiverSelected slots to unused
    this.slots.video.unused.push(...remove(this.slots.video.receiverSelected, (slot) => !isCsiNeededByCurrentLayout(slot.csi)));
  }

  /**
   * Releases all the "unused" slots.
   */
  private releaseUnusedSlots() {
    this.slots.video.unused.forEach((slot) => this.receiveSlotManager.releaseSlot(slot));
    this.slots.video.unused.length = 0;
  }

  /**
   * Allocates receive slots to all video panes in the current selected layout
   */
  private allocateSlotsToVideoPaneGroups() {
    this.receiveSlotAllocations = {activeSpeaker: {}, receiverSelected: {}};

    this.currentLayout?.activeSpeakerVideoPaneGroups?.forEach((group) => {
      this.receiveSlotAllocations.activeSpeaker[group.id] = {slots: []};

      for (let paneIndex = 0; paneIndex < group.numPanes; paneIndex += 1) {
        // allocate a slot from the "unused" list
        const freeSlot = this.slots.video.unused.pop();

        if (freeSlot) {
          this.slots.video.activeSpeaker.push(freeSlot);
          this.receiveSlotAllocations.activeSpeaker[group.id].slots.push(freeSlot);
        }
      }
    });

    this.currentLayout?.memberVideoPanes?.forEach((memberPane) => {
      // check if there is existing slot for this csi
      const existingSlot = this.slots.video.receiverSelected.find((slot) => slot.csi === memberPane.csi);

      if (memberPane.csi !== undefined && existingSlot) {
        // found it, so use it
        this.receiveSlotAllocations.receiverSelected[memberPane.id] = existingSlot;
      }
      else {
        // allocate a slot from the "unused" list
        const freeSlot = this.slots.video.unused.pop();

        if (freeSlot) {
          this.slots.video.receiverSelected.push(freeSlot);
          this.receiveSlotAllocations.receiverSelected[memberPane.id] = freeSlot;
        }
      }
    });

    console.log('marcin2: this.receiveSlotAllocations=', this.receiveSlotAllocations);
  }

  /**
   * Makes sure we have the right number of receive slots created for the current layout
   * and allocates them to the right video pane groups
   *
   * @returns {Promise}
   */
  private async updateReceiveSlots() {
    const requiredNumSlots = this.getRequiredNumVideoSlotsForLayout(this.currentLayout);
    const totalNumSlots = this.slots.video.unused.length + this.slots.video.activeSpeaker.length + this.slots.video.receiverSelected.length;

    // ensure we have enough total slots for current layout
    if (totalNumSlots < requiredNumSlots) {
      let numSlotsToCreate = requiredNumSlots - totalNumSlots;

      while (numSlotsToCreate > 0) {
        // eslint-disable-next-line no-await-in-loop
        this.slots.video.unused.push(await this.receiveSlotManager.allocateSlot(MC.MediaType.VideoMain));
        numSlotsToCreate -= 1;
      }
    }

    // move all no longer needed receiver-selected slots to "unused"
    this.trimReceiverSelectedSlots();

    // move all active speaker slots to "unused"
    this.slots.video.unused.push(...this.slots.video.activeSpeaker);
    this.slots.video.activeSpeaker.length = 0;

    // allocate the slots to the right pane groups
    this.allocateSlotsToVideoPaneGroups();

    console.log('marcin2: receive slots updated:');
    console.log('marcin2: unused=', this.slots.video.unused);
    console.log('marcin2: activeSpeaker=', this.slots.video.activeSpeaker);
    console.log('marcin2: receiverSelected=', this.slots.video.receiverSelected);

    // If this is the initial layout, there may be some "unused" slots left because of the preallocation
    // done in this.preallocateVideoReceiveSlots(), so release them now
    this.releaseUnusedSlots();
  }


  /**
   * Creates new RemoteMedia and RemoteMediaGroup objects for the current layout
   * and sends the media requests for all of them.
   */
  private updateRemoteMediaObjects() {
    // invalidate all the previous remote media objects and cancel their media requests
    this.invalidateCurrentRemoteMedia({audio: false, video: true, commit: false});

    // create new remoteMediaGroup objects
    this.media.video.activeSpeakerVideoPanes = {};
    this.media.video.memberVideoPanes = {};

    for (const [groupId, group] of Object.entries(this.receiveSlotAllocations.activeSpeaker)) {
      const paneGroupInCurrentLayout = this.currentLayout?.activeSpeakerVideoPaneGroups?.find((groupInLayout) => groupInLayout.id === groupId);

      if (paneGroupInCurrentLayout) {
        const mediaGroup = new RemoteMediaGroup(
          this.mediaRequestManagers.video,
          group.slots,
          paneGroupInCurrentLayout.priority,
          {
            preferLiveVideo: this.config.video.preferLiveVideo,
            resolution: paneGroupInCurrentLayout.size
          }
        );

        mediaGroup.sendMediaRequest(false);

        this.media.video.activeSpeakerVideoPanes[groupId] = mediaGroup;
      }
      else {
        // this should never happen, because this.receiveSlotAllocations are created based on current layout configuration
        console.log(`a group id ${groupId} from this.receiveSlotAllocations.activeSpeaker cannot be found in the current layout configuration`);
      }
    }

    // create new remoteMedia objects
    for (const [paneId, slot] of Object.entries(this.receiveSlotAllocations.receiverSelected)) {
      const paneInCurrentLayout = this.currentLayout?.memberVideoPanes?.find((paneInLayout) => paneInLayout.id === paneId);

      if (paneInCurrentLayout) {
        const remoteMedia = new RemoteMedia(slot, this.mediaRequestManagers.video, {
          resolution: paneInCurrentLayout.size
        });

        if (paneInCurrentLayout.csi) {
          remoteMedia.sendMediaRequest(paneInCurrentLayout.csi, false);
        }

        this.media.video.memberVideoPanes[paneId] = remoteMedia;
      }
      else {
        // this should never happen, because this.receiveSlotAllocations are created based on current layout configuration
        console.log(`a pane id ${paneId} from this.receiveSlotAllocations.receiverSelected cannot be found in the current layout configuration`);
      }
    }

    // todo: screenshare

    this.mediaRequestManagers.video.commit();
  }

  /**
   * Invalidates all remote media objects belonging to currently selected layout
   */
  private invalidateCurrentRemoteMedia(options: {audio: boolean, video: boolean, commit: boolean}) {
    const {audio, video, commit} = options;

    if (audio && this.media.audio) {
      this.media.audio.cancelMediaRequest(commit);
      this.media.audio.invalidate();
    }
    if (video) {
      Object.values(this.media.video.activeSpeakerVideoPanes).forEach((remoteMediaGroup) => {
        remoteMediaGroup.cancelMediaRequest(commit);
        remoteMediaGroup.invalidate();
      });
      Object.values(this.media.video.memberVideoPanes).forEach((remoteMedia) => {
        remoteMedia.cancelMediaRequest(commit);
        remoteMedia.invalidate();
      });
    }
  }

  /** emits Event.VideoLayoutChanged */
  private emitVideoLayoutChangedEvent() {
    // todo: at this point the receive slots might still be showing a participant from previous layout, we should
    // wait for our media requests to be fullfilled, but there is no API for that right now (we could wait for source updates
    // but in some cases they might never come, or would need to always make sure to use a new set of receiver slots)

    // todo: use scoped events like all other places in sdk
    this.emit(
      Event.VideoLayoutChanged,
      {
        layoutId: this.currentLayoutId,
        activeSpeakerVideoPanes: this.media.video.activeSpeakerVideoPanes,
        memberVideoPanes: this.media.video.memberVideoPanes,
        screenShareVideo: undefined, // todo: screen share
      }
    );

    // if a receive slot was re-used then the client may get a RemoteMedia instance that has media already running
    // and so they will not get a MediaStarted event for it and we need to trigger it manually
    Object.values(this.media.video.activeSpeakerVideoPanes).forEach((remoteMediaGroup) => {
      remoteMediaGroup.checkMediaAlreadyStarted();
    });
    Object.values(this.media.video.memberVideoPanes).forEach((remoteMedia) => {
      remoteMedia.checkMediaAlreadyStarted();
    });
  }

  /**
   * Sets a new CSI on a given remote media object
   *
   * @param {RemoteMedia} remoteMedia remote Media object to modify
   * @param {CSI} csi new CSI value, can be null if we want to stop receiving media
   */
  public setRemoteVideoCsi(remoteMedia: RemoteMedia, csi: CSI | null) {
    if (!Object.values(this.media.video.memberVideoPanes).includes(remoteMedia)) {
      throw new Error('remoteMedia not found');
    }

    if (csi) {
      remoteMedia.sendMediaRequest(csi, true);
    }
    else {
      remoteMedia.cancelMediaRequest(true);
    }
  }

  /**
   * Adds a new member video pane to the currently selected layout.
   *
   * Changes to the layout are lost after a layout change.
   *
   * @param {MemberVideoPane} newPane
   * @returns {Promise<RemoteMedia>}
   */
  // public addMemberVideoPane(newPane: MemberVideoPane): Promise<RemoteMedia> {
  // // todo: add entry to memberVideoPanes list in current layout config
  // // todo: alocate slot, create RemoteMedia, call RemoteMedia.sendMediaRequest()
  // // todo: return the new remoteMedia
  // }

  /**
   * Removes a member video pane from the currently selected layout.
   *
   * Changes to the layout are lost after a layout change.
   *
   * @param {PaneId} paneId pane id of the pane to remove
   * @returns {Promise<RemoteMedia>}
   */
  // public removeMemberVideoPane(paneId: PaneId): void { // maybe not needed
  // // todo: invalidate remoteMedia, release slot, cancel media request (with sendUpdate: true)
  // // todo: remove from memberVideoPanes list in current layout config
  // }


  /**
   * Pins an active speaker remote media object to the given CSI value. From that moment
   * onwards the remote media will only play audio/video from that specific CSI until
   * unpinActiveSpeakerVideoPane() is called or current layout is changed.
   *
   * @param {RemoteMedia} remoteMedia remote Media object reference
   * @param {CSI} csi CSI value to pin to, if undefined, then current CSI value is used
   */
  public pinActiveSpeakerVideoPane(remoteMedia: RemoteMedia, csi?: CSI): void {
    if (!Object.values(this.media.video.activeSpeakerVideoPanes).some((group) => group.includes(remoteMedia))) {
      throw new Error('remoteMedia not found among the active speaker remote media groups');
    }
    // todo: find the remoteMedia (check that it's in an active speaker group)

    // remoteMedia.pin(csi); // todo: implement pin in remoteMedia
  }

  public unpinActiveSpeakerVideoPane(remoteMedia: RemoteMedia) {
    // todo: find the remoteMedia (check that it's in an active speaker group)
    // todo: call RemoteMediaGroup.unpin()
  }
}
