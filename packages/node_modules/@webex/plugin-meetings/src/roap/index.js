import {StatelessWebexPlugin} from '@webex/webex-core';

import {ROAP} from '../constants';
import LoggerProxy from '../common/logs/logger-proxy';

import RoapHandler from './handler';
import RoapRequest from './request';
import RoapCollection from './collection';

/**
 * Roap options
 * @typedef {Object} RoapOptions
 * @property {String} sdp
 * @property {Meeting} meeting
 * @property {Number} roapSeq
 * @property {Boolean} reconnect
 */

/**
  * @typedef {Object} SeqOptions
  * @property {String} correlationId
  * @property {String} mediaId
  * @property {Number} seq
  */

/**
 * @class Roap
 * @export
 * @private
 */
export default class Roap extends StatelessWebexPlugin {
  /**
   *
   * @param {Object} attrs
   * @param {Object} options
   */
  constructor(attrs, options) {
    super({}, options);
    /**
     * @instance
     * @type {Object}
     * @private
     * @memberof Roap
     */
    this.attrs = attrs;
    /**
     * @instance
     * @type {Object}
     * @private
     * @memberof Roap
     */
    this.options = options;
    /**
     * The Roap Process State Handler
     * @instance
     * @type {RoapHandler}
     * @private
     * @memberof Roap
     */
    this.roapHandler = new RoapHandler(this.attrs, this.options, this.sendRoapOK.bind(this), this.sendRoapAnswer.bind(this), this.roapFinished.bind(this));
    /**
     * The Roap Request Server Proxy Object
     * @instance
     * @type {RoapRequest}
     * @private
     * @memberof Roap
     */
    this.roapRequest = new RoapRequest({}, options);
    /**
     * The last roap offer sent to server and acked
     * @instance
     * @type {Object}
     * @private
     * @memberof Roap
     */
    this.lastRoapOffer = {};
  }

  /**
   *
   * @param {SeqOptions} options
   * @returns {null}
   * @private
   * @memberof Roap
   */
  sendRoapOK(options) {
    return Promise.resolve().then(() => {
      const meeting = this.webex.meetings.meetingCollection.getByKey('correlationId', options.correlationId);
      const roapMessage = {
        messageType: ROAP.ROAP_TYPES.OK,
        version: ROAP.ROAP_VERSION,
        seq: options.seq
      };

      LoggerProxy.logger.log(`Roap:index#sendRoapOK --> ROAP OK sending with seq ${options.seq}`);

      return this.roapRequest
        .sendRoap({
          roapMessage,
          locusSelfUrl: meeting.selfUrl,
          mediaId: options.mediaId,
          correlationId: options.correlationId,
          audioMuted: meeting.isAudioMuted(),
          videoMuted: meeting.isVideoMuted(),
          meetingId: meeting.id
        })
        .then(() => {
          LoggerProxy.logger.log(`Roap:index#sendRoapOK --> ROAP OK sent with seq ${options.seq}`);
        });
    });
  }

  /**
   * Sends a ROAP answer...
   * @param {SeqOptions} options
   * @param {Boolean} options.audioMuted
   * @param {Boolean} options.videoMuted
   * @returns {Promise}
   * @private
   * @memberof Roap
   */
  sendRoapAnswer(options) {
    const meeting = this.webex.meetings.meetingCollection.getByKey('correlationId', options.correlationId);
    const roapMessage = {
      messageType: ROAP.ROAP_TYPES.ANSWER,
      sdps: [options.sdp],
      version: ROAP.ROAP_VERSION,
      seq: options.seq
    };

    return this.roapRequest
      .sendRoap({
        roapMessage,
        locusSelfUrl: meeting.selfUrl,
        mediaId: options.mediaId,
        correlationId: options.correlationId,
        audioMuted: meeting.isAudioMuted(),
        videoMuted: meeting.isVideoMuted(),
        meetingId: meeting.id
      });
  }

  /**
   * Sends a ROAP error...
   * @param {Object} options
   * @returns {Promise}
   * @private
   * @memberof Roap
   */
  sendRoapError(options) {
    const meeting = this.webex.meetings.meetingCollection.getByKey('correlationId', options.correlationId);
    const roapMessage = {
      messageType: ROAP.ROAP_TYPES.ERROR,
      version: ROAP.ROAP_VERSION,
      errorType: options.errorType,
      seq: options.seq

    };

    return this.roapRequest.sendRoap({
      roapMessage,
      locusSelfUrl: meeting.selfUrl,
      mediaId: options.mediaId,
      correlationId: options.correlationId,
      audioMuted: meeting.isAudioMuted(),
      videoMuted: meeting.isVideoMuted(),
      meetingId: meeting.id
    })
      .then(() => {
        LoggerProxy.logger.log(`Roap:index#sendRoapError --> ROAP ERROR sent with seq ${options.seq}`);
      });
  }

  /**
   * sends a roap media request
   * @param {RoapOptions} options
   * @returns {Promise}
   * @private
   * @memberof Roap
   */
  sendRoapMediaRequest(options) {
    const {
      meeting, seq, sdp, reconnect, tieBreaker
    } = options;
    const roapMessage = {
      messageType: ROAP.ROAP_TYPES.OFFER,
      sdps: [sdp],
      version: ROAP.ROAP_VERSION,
      seq,
      tieBreaker
    };

    return this.roapRequest
      .sendRoap({
        roapMessage,
        correlationId: meeting.correlationId,
        locusSelfUrl: meeting.selfUrl,
        mediaId: reconnect ? '' : meeting.mediaId,
        audioMuted: meeting.isAudioMuted(),
        videoMuted: meeting.isVideoMuted(),
        meetingId: meeting.id
      })
      .then(({locus, mediaConnections}) => {
        if (mediaConnections) {
          meeting.updateMediaConnections(mediaConnections);
        }

        return locus;
      });
  }

  /**
 * Called when the roap sequence is finished (completed successfully or failed)
 * @param {String} correlationId id of the meeting affected
 * @param {String} sequenceId the id of the finished sequence
 * @returns {undefined}
 * @private
 * @memberof Roap
 */
  roapFinished(correlationId, sequenceId) {
    RoapCollection.onSessionSequenceFinish(correlationId, sequenceId);
    const meeting = this.webex.meetings.meetingCollection.getByKey('correlationId', correlationId);

    meeting.mediaNegotiatedEvent(); // todo: make sure this is called
    if (!RoapCollection.isBusy(correlationId)) {
      meeting.processNextQueuedMediaUpdate();
    }
  }
}
